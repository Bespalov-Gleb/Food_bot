<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ресторан</title>
    <link rel="stylesheet" href="/static/styles.v23.css?v=40" />
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <!-- Кнопка "Назад" -->
    <button class="back-button" onclick="history.back()">←</button>

    <div class="container">
        <div id="restaurant-info">
            <!-- Информация о ресторане будет загружена динамически -->
        </div>
        
        <div id="categories">
            <!-- Категории будут загружены динамически -->
        </div>
        
        <div id="dishes">
            <!-- Блюда будут загружены динамически -->
        </div>
    </div>

    <!-- Нижняя панель оформления заказа -->
    <div class="checkout-bar" id="checkout-bar" style="display: none;">
        <div class="checkout-info">
            <div class="cart-count" id="cart-count">0</div>
            <div>
                <div class="checkout-total" id="checkout-total">0 ₽</div>
                <div class="checkout-note">Минимум 500 ₽</div>
            </div>
        </div>
        <button class="checkout-button" onclick="goToCart()">Оформить заказ</button>
    </div>

    <script>
        const api = location.origin + '/api';
        const tg = window.Telegram?.WebApp;
        const q = new URLSearchParams(location.search);
        const uid = (q.get('uid') && Number(q.get('uid'))) || tg?.initDataUnsafe?.user?.id || 0;
        const headers = uid ? { 'X-Telegram-User-Id': String(uid) } : {};
        
        let restaurantId = Number(q.get('id')) || 0;
        let categories = [];
        let dishes = [];
        let cart = { items: [] };
        let dishesMap = new Map();
        let restaurantsMap = new Map();
        let activeCategory = null;
        
        async function loadMenu() {
          try {
            const [catRes, dishRes, restRes] = await Promise.all([
              fetch(api + '/categories?restaurant_id=' + restaurantId + (uid ? ('&uid=' + uid) : ''), { headers }),
              fetch(api + '/dishes?restaurant_id=' + restaurantId + (uid ? ('&uid=' + uid) : ''), { headers }),
              fetch(api + '/restaurants/' + restaurantId + (uid ? ('?uid=' + uid) : ''), { headers })
            ]);
            
            categories = await catRes.json();
            dishes = await dishRes.json();
            const restaurant = await restRes.json();
            
            restaurantsMap.set(restaurant.id, restaurant);
            
            // Заполняем карту блюд
            dishes.forEach(dish => {
              dishesMap.set(dish.id, dish);
            });
            
            renderRestaurantHeader(restaurant);
            renderCategories();
            renderDishes();
            
          } catch (error) {
            console.error('Error loading menu:', error);
          }
        }
        
        function renderRestaurantHeader(restaurant) {
          const container = document.getElementById('restaurant-info');
          container.innerHTML = `
            <div class="restaurant-header">
              <h1 class="restaurant-name">${restaurant.name}</h1>
              <div class="restaurant-meta">
                <span>★ 4.6 • 48 отзывов</span>
                <span>35–45 мин</span>
              </div>
              <div class="restaurant-address">${restaurant.address || 'Адрес не указан'}</div>
            </div>
          `;
        }
        
        function renderCategories() {
          const container = document.getElementById('categories');
          const row = document.createElement('div');
          row.className = 'cat-row';
          row.id = 'categoriesRow';
          
          categories.forEach(category => {
            const button = document.createElement('button');
            button.textContent = category.name;
            button.onclick = () => {
              activeCategory = category.id;
              updateActiveCategory();
              scrollToCategory(category.id);
            };
            row.appendChild(button);
          });
          
          container.appendChild(row);
          
          // Активируем первую категорию по умолчанию
          if (categories.length > 0) {
            activeCategory = categories[0].id;
            updateActiveCategory();
          }
        }
        
        function updateActiveCategory() {
          // Обновляем активную категорию в кнопках
          document.querySelectorAll('.cat-row button').forEach(btn => {
            btn.classList.remove('active');
          });
          
          if (activeCategory) {
            const activeBtn = Array.from(document.querySelectorAll('.cat-row button')).find(btn => {
              const category = categories.find(c => c.name === btn.textContent);
              return category && category.id === activeCategory;
            });
            if (activeBtn) activeBtn.classList.add('active');
          }
        }
        
        function scrollToCategory(categoryId) {
          const categoryElement = document.querySelector(`[data-category="${categoryId}"]`);
          if (categoryElement) {
            categoryElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
        
        function renderDishes() {
          const container = document.getElementById('dishes');
          container.innerHTML = '';
          
          // Группируем блюда по категориям
          const dishesByCategory = {};
          dishes.forEach(dish => {
            if (!dishesByCategory[dish.category_id]) {
              dishesByCategory[dish.category_id] = [];
            }
            dishesByCategory[dish.category_id].push(dish);
          });
          
          // Рендерим каждую категорию
          categories.forEach(category => {
            const categoryDishes = dishesByCategory[category.id] || [];
            if (categoryDishes.length === 0) return;
            
            const categoryContainer = document.createElement('div');
            categoryContainer.className = 'category-section';
            categoryContainer.setAttribute('data-category', category.id);
            
            const categoryTitle = document.createElement('h2');
            categoryTitle.className = 'category-title';
            categoryTitle.textContent = category.name;
            categoryContainer.appendChild(categoryTitle);
            
            const dishesGrid = document.createElement('div');
            dishesGrid.className = 'dishes-grid';
            
            categoryDishes.forEach(dish => {
              const card = document.createElement('div');
              card.className = 'dish-card';
              
              card.innerHTML = `
                <img src="${dish.image || 'https://via.placeholder.com/300x200?text=No+Image'}" alt="${dish.name}" class="dish-image" />
                <div class="dish-content">
                  <h3 class="dish-name">${dish.name}</h3>
                  <p class="dish-description">${dish.description || 'Описание отсутствует'}</p>
                  <div class="dish-price">${dish.price || 0} ₽</div>
                  <div class="dish-controls">
                    <div class="controls" data-dish="${dish.id}">
                      <button class="add-btn">+</button>
                    </div>
                  </div>
                </div>
              `;
              
              const controls = card.querySelector('.controls');
              const addBtn = controls.querySelector('.add-btn');
              addBtn.onclick = () => {
                if (dish.has_options) {
                  const p = new URLSearchParams(location.search);
                  if (!p.get('ngrok-skip-browser-warning')) p.set('ngrok-skip-browser-warning','1');
                  location.href = '/static/dish.html?id=' + dish.id + '&' + p.toString();
                } else {
                  updateQtyClient(dish.id, 1);
                }
              };
              dishesGrid.appendChild(card);
            });
            
            categoryContainer.appendChild(dishesGrid);
            container.appendChild(categoryContainer);
          });
          
          loadCartAndSync();
        }
        
        async function addToCart(dishId, deltaQty) {
          const dish = dishesMap.get(dishId);
          const cartData = { 
            restaurant_id: dish.restaurant_id, 
            dish_id: dish.id, 
            qty: deltaQty,
            chosen_options: [] // Добавляем пустой массив опций
          };
          
          console.log('Adding to cart from restaurant:', cartData);
          
          const res = await fetch(location.origin + '/api/cart/items' + (uid ? ('?uid=' + uid) : ''), {
            method: 'POST',
            headers,
            body: JSON.stringify(cartData)
          });
          
          console.log('Response status:', res.status);
          
          if (!res.ok) {
            const errorText = await res.text();
            console.error('Error response:', errorText);
            throw new Error(`HTTP ${res.status}: ${errorText}`);
          }
          
          const data = await res.json();
          console.log('Response data:', data);
          
          if (data.status === 'too_many_restaurants') {
            showTooManyModal(data.current_restaurant_ids || [], async () => {
              await fetch(location.origin + '/api/cart/items?force=true' + (uid ? ('&uid=' + uid) : ''), { 
                method: 'POST', 
                headers, 
                body: JSON.stringify(cartData) 
              });
              await loadCartAndSync();
            });
          } else {
            await loadCartAndSync();
          }
        }
        
        async function loadCartAndSync() {
          const res = await fetch(api + '/cart' + (uid ? ('?uid=' + uid) : ''), { headers });
          cart = await res.json();
          renderQtyControls();
          updateOrderSummary();
        }
        
        function getQtyForDish(dishId) {
          return cart.items.filter(i => i.dish_id === dishId && dishesMap.get(i.dish_id)?.restaurant_id === restaurantId)
            .reduce((s, i) => s + i.qty, 0);
        }
        
        function renderQtyControls() {
          document.querySelectorAll('.controls').forEach(c => {
            const dishId = Number(c.getAttribute('data-dish'));
            const dish = dishesMap.get(dishId);
            const qty = getQtyForDish(dishId);
            
            if (qty <= 0) {
              // Кнопка "+" для добавления блюда
              c.innerHTML = '<button class="add-btn">+</button>';
              c.querySelector('.add-btn').onclick = () => {
                if (dish?.has_options) {
                  const p = new URLSearchParams(location.search);
                  if (!p.get('ngrok-skip-browser-warning')) p.set('ngrok-skip-browser-warning', '1');
                  location.href = '/static/dish.html?id=' + dishId + '&' + p.toString();
                } else {
                  updateQtyClient(dishId, 1);
                }
              };
            } else {
              // Контролы с количеством: "-" количество "+"
              c.innerHTML = `
                <div class="qty">
                  <button data-act="dec" title="Уменьшить количество">−</button>
                  <span class="quantity">${qty}</span>
                  <button data-act="inc" title="Увеличить количество">+</button>
                </div>
              `;
              
              // Обработчик для кнопки "-"
              c.querySelector('[data-act="dec"]').onclick = () => updateQtyClient(dishId, -1);
              
              // Обработчик для кнопки "+"
              c.querySelector('[data-act="inc"]').onclick = () => {
                if (dish?.has_options) {
                  const p = new URLSearchParams(location.search);
                  if (!p.get('ngrok-skip-browser-warning')) p.set('ngrok-skip-browser-warning', '1');
                  location.href = '/static/dish.html?id=' + dishId + '&' + p.toString();
                } else {
                  updateQtyClient(dishId, 1);
                }
              };
            }
          });
        }
        
        async function updateQtyClient(dishId, delta) {
          if (delta > 0) {
            await addToCart(dishId, 1);
          } else {
            const item = cart.items.find(i => i.dish_id === dishId && dishesMap.get(i.dish_id)?.restaurant_id === restaurantId);
            if (item) {
              const newQty = Math.max(0, item.qty - 1);
              if (newQty === 0) {
                await fetch(api + '/cart/items/' + item.id + (uid ? ('&uid=' + uid) : ''), { method: 'DELETE', headers });
              } else {
                await fetch(api + '/cart/items/' + item.id + '?qty=' + newQty + (uid ? ('&uid=' + uid) : ''), { method: 'PATCH', headers });
              }
              await loadCartAndSync();
            }
          }
        }
        
        function calcTotalForRestaurant() {
          return cart.items.reduce((sum, it) => {
            const d = dishesMap.get(it.dish_id);
            if (!d || d.restaurant_id !== restaurantId) return sum;
            return sum + (d.price || 0) * it.qty;
          }, 0);
        }
        
        function updateOrderSummary() {
          const sum = calcTotalForRestaurant();
          const totalItems = cart.items.filter(i => {
            const d = dishesMap.get(i.dish_id);
            return d && d.restaurant_id === restaurantId;
          }).reduce((s, i) => s + i.qty, 0);
          
          // Обновляем количество товаров
          document.getElementById('cart-count').textContent = totalItems;
          document.getElementById('checkout-total').textContent = sum + ' ₽';
          
          // Показываем/скрываем нижнюю плашку
          const checkoutBar = document.getElementById('checkout-bar');
          
          if (sum > 0) {
            checkoutBar.style.display = 'block';
          } else {
            checkoutBar.style.display = 'none';
          }
        }
        
        // Функция для перехода к корзине
        function goToCart() {
          const p = new URLSearchParams(location.search);
          if (!p.get('ngrok-skip-browser-warning')) p.set('ngrok-skip-browser-warning', '1');
          p.set('r', String(restaurantId));
          location.href = '/static/cart.html?' + p.toString();
        }
        
        // Modal for too many restaurants
        function ensureOverlay() {
          let ov = document.getElementById('ov');
          if (!ov) {
            ov = document.createElement('div');
            ov.id = 'ov';
            ov.className = 'overlay';
            ov.innerHTML = '<div class="modal"><h3>Слишком много корзин</h3><div class="muted">Удалите корзину, чтобы собрать новую</div><div id="ovList"></div><div style="margin-top:10px;text-align:right"><button id="ovDone" class="primary">Готово</button></div></div>';
            document.body.appendChild(ov);
          }
          return ov;
        }
        
        async function showTooManyModal(restIds, onDone) {
          const ov = ensureOverlay();
          const list = ov.querySelector('#ovList');
          list.innerHTML = '';
          
          // Load names
          const resR = await fetch(api + '/restaurants/_bulk?ids=' + encodeURIComponent(restIds.join(',')) + (uid ? ('&uid=' + uid) : ''), { headers });
          const rests = resR.ok ? await resR.json() : [];
          rests.forEach(r => {
            const row = document.createElement('div');
            row.className = 'row';
            row.innerHTML = `<div>${r.name}</div><button class="trash">🗑</button>`;
            row.querySelector('.trash').onclick = async () => {
              await fetch(api + '/cart/clear?restaurant_id=' + r.id + (uid ? ('&uid=' + uid) : ''), { method: 'POST', headers });
              row.remove();
            };
            list.appendChild(row);
          });
          ov.style.display = 'flex';
          ov.querySelector('#ovDone').onclick = async () => {
            ov.style.display = 'none';
            if (onDone) await onDone();
          };
        }
        
        // Primary initialization
        loadMenu();
        
        // Add scroll handler for updating active category
        window.addEventListener('scroll', updateActiveCategory);
    </script>
</body>
</html>